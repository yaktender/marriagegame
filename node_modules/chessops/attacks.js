"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.between = exports.ray = exports.attacks = exports.queenAttacks = exports.rookAttacks = exports.bishopAttacks = exports.pawnAttacks = exports.knightAttacks = exports.kingAttacks = void 0;
const util_1 = require("./util");
const squareSet_1 = require("./squareSet");
function computeRange(square, deltas) {
    let range = squareSet_1.SquareSet.empty();
    for (const delta of deltas) {
        const sq = square + delta;
        if (0 <= sq && sq < 64 && Math.abs(util_1.squareFile(square) - util_1.squareFile(sq)) <= 2) {
            range = range.with(sq);
        }
    }
    return range;
}
function tabulate(f) {
    const table = [];
    for (let square = 0; square < 64; square++)
        table[square] = f(square);
    return table;
}
const KING_ATTACKS = tabulate(sq => computeRange(sq, [-9, -8, -7, -1, 1, 7, 8, 9]));
const KNIGHT_ATTACKS = tabulate(sq => computeRange(sq, [-17, -15, -10, -6, 6, 10, 15, 17]));
const PAWN_ATTACKS = {
    white: tabulate(sq => computeRange(sq, [7, 9])),
    black: tabulate(sq => computeRange(sq, [-7, -9])),
};
function kingAttacks(square) {
    return KING_ATTACKS[square];
}
exports.kingAttacks = kingAttacks;
function knightAttacks(square) {
    return KNIGHT_ATTACKS[square];
}
exports.knightAttacks = knightAttacks;
function pawnAttacks(color, square) {
    return PAWN_ATTACKS[color][square];
}
exports.pawnAttacks = pawnAttacks;
const FILE_RANGE = tabulate(sq => squareSet_1.SquareSet.fromFile(util_1.squareFile(sq)).without(sq));
const RANK_RANGE = tabulate(sq => squareSet_1.SquareSet.fromRank(util_1.squareRank(sq)).without(sq));
const DIAG_RANGE = tabulate(sq => {
    const diag = new squareSet_1.SquareSet(134480385, 2151686160);
    const shift = 8 * (util_1.squareRank(sq) - util_1.squareFile(sq));
    return (shift >= 0 ? diag.shl64(shift) : diag.shr64(-shift)).without(sq);
});
const ANTI_DIAG_RANGE = tabulate(sq => {
    const diag = new squareSet_1.SquareSet(270549120, 16909320);
    const shift = 8 * (util_1.squareRank(sq) + util_1.squareFile(sq) - 7);
    return (shift >= 0 ? diag.shl64(shift) : diag.shr64(-shift)).without(sq);
});
function hyperbola(bit, range, occupied) {
    let forward = occupied.intersect(range);
    let reverse = forward.bswap64(); // Assumes no more than 1 bit per rank
    forward = forward.minus64(bit);
    reverse = reverse.minus64(bit.bswap64());
    return forward.xor(reverse.bswap64()).intersect(range);
}
function fileAttacks(square, occupied) {
    return hyperbola(squareSet_1.SquareSet.fromSquare(square), FILE_RANGE[square], occupied);
}
function rankAttacks(square, occupied) {
    const range = RANK_RANGE[square];
    let forward = occupied.intersect(range);
    let reverse = forward.rbit64();
    forward = forward.minus64(squareSet_1.SquareSet.fromSquare(square));
    reverse = reverse.minus64(squareSet_1.SquareSet.fromSquare(63 - square));
    return forward.xor(reverse.rbit64()).intersect(range);
}
function bishopAttacks(square, occupied) {
    const bit = squareSet_1.SquareSet.fromSquare(square);
    return hyperbola(bit, DIAG_RANGE[square], occupied).xor(hyperbola(bit, ANTI_DIAG_RANGE[square], occupied));
}
exports.bishopAttacks = bishopAttacks;
function rookAttacks(square, occupied) {
    return fileAttacks(square, occupied).xor(rankAttacks(square, occupied));
}
exports.rookAttacks = rookAttacks;
function queenAttacks(square, occupied) {
    return bishopAttacks(square, occupied).xor(rookAttacks(square, occupied));
}
exports.queenAttacks = queenAttacks;
function attacks(piece, square, occupied) {
    switch (piece.role) {
        case 'pawn': return pawnAttacks(piece.color, square);
        case 'knight': return knightAttacks(square);
        case 'bishop': return bishopAttacks(square, occupied);
        case 'rook': return rookAttacks(square, occupied);
        case 'queen': return queenAttacks(square, occupied);
        case 'king': return kingAttacks(square);
    }
}
exports.attacks = attacks;
function ray(a, b) {
    const other = squareSet_1.SquareSet.fromSquare(b);
    if (RANK_RANGE[a].intersects(other))
        return RANK_RANGE[a].with(a);
    if (ANTI_DIAG_RANGE[a].intersects(other))
        return ANTI_DIAG_RANGE[a].with(a);
    if (DIAG_RANGE[a].intersects(other))
        return DIAG_RANGE[a].with(a);
    if (FILE_RANGE[a].intersects(other))
        return FILE_RANGE[a].with(a);
    return squareSet_1.SquareSet.empty();
}
exports.ray = ray;
function between(a, b) {
    return ray(a, b).intersect(squareSet_1.SquareSet.full().shl64(a).xor(squareSet_1.SquareSet.full().shl64(b))).withoutFirst();
}
exports.between = between;
//# sourceMappingURL=attacks.js.map