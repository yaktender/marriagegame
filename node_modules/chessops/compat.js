"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.lichessVariantRules = exports.scalachessCharPair = exports.chessgroundMove = exports.chessgroundDests = void 0;
const types_1 = require("./types");
const util_1 = require("./util");
function chessgroundDests(pos, opts) {
    const result = new Map();
    const ctx = pos.ctx();
    for (const [from, squares] of pos.allDests(ctx)) {
        if (squares.nonEmpty()) {
            const d = Array.from(squares, util_1.makeSquare);
            if (!(opts === null || opts === void 0 ? void 0 : opts.chess960) && from === ctx.king && util_1.squareFile(from) === 4) {
                // Chessground needs both types of castling dests and filters based on
                // a rookCastles setting.
                if (squares.has(0))
                    d.push('c1');
                else if (squares.has(56))
                    d.push('c8');
                if (squares.has(7))
                    d.push('g1');
                else if (squares.has(63))
                    d.push('g8');
            }
            result.set(util_1.makeSquare(from), d);
        }
    }
    return result;
}
exports.chessgroundDests = chessgroundDests;
function chessgroundMove(move) {
    return types_1.isDrop(move) ? [util_1.makeSquare(move.to)] : [util_1.makeSquare(move.from), util_1.makeSquare(move.to)];
}
exports.chessgroundMove = chessgroundMove;
function scalachessCharPair(move) {
    if (types_1.isDrop(move))
        return String.fromCharCode(35 + move.to, 35 + 64 + 8 * 5 + ['queen', 'rook', 'bishop', 'knight', 'pawn'].indexOf(move.role));
    else
        return String.fromCharCode(35 + move.from, move.promotion ?
            (35 + 64 + 8 * ['queen', 'rook', 'bishop', 'knight', 'king'].indexOf(move.promotion) + util_1.squareFile(move.to)) :
            (35 + move.to));
}
exports.scalachessCharPair = scalachessCharPair;
function lichessVariantRules(variant) {
    switch (variant) {
        case 'standard':
        case 'chess960':
        case 'fromPosition':
            return 'chess';
        case 'threeCheck':
            return '3check';
        case 'kingOfTheHill':
            return 'kingofthehill';
        case 'racingKings':
            return 'racingkings';
        default:
            return variant;
    }
}
exports.lichessVariantRules = lichessVariantRules;
//# sourceMappingURL=compat.js.map